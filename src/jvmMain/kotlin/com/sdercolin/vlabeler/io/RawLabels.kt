package com.sdercolin.vlabeler.io

import androidx.compose.runtime.Immutable
import com.sdercolin.vlabeler.env.Log
import com.sdercolin.vlabeler.env.isDebug
import com.sdercolin.vlabeler.model.Entry
import com.sdercolin.vlabeler.model.LabelerConf
import com.sdercolin.vlabeler.model.ModuleDefinition
import com.sdercolin.vlabeler.model.Project
import com.sdercolin.vlabeler.model.postApplyLabelerConf
import com.sdercolin.vlabeler.util.JavaScript
import com.sdercolin.vlabeler.util.ParamMap
import com.sdercolin.vlabeler.util.ParamTypedMap
import com.sdercolin.vlabeler.util.Resources
import com.sdercolin.vlabeler.util.execResource
import com.sdercolin.vlabeler.util.matchGroups
import com.sdercolin.vlabeler.util.readTextByEncoding
import com.sdercolin.vlabeler.util.replaceWithVariables
import com.sdercolin.vlabeler.util.resolve
import com.sdercolin.vlabeler.util.roundToDecimalDigit
import kotlinx.serialization.Serializable
import java.io.File

/**
 * Create a list of entry from raw labels.
 *
 * @param sources The raw labels.
 * @param inputFile The input file. Could be null, which means the raw labels are generated by a template plugin.
 * @param labelerConf The labeler.
 * @param labelerParams The labeler parameters.
 * @param labelerTypedParams The labeler typed parameters. Either [labelerParams] or [labelerTypedParams] should be
 *     provided.
 * @param sampleFiles The sample files.
 * @param encoding The encoding of the input file, passed to the JavaScript environment.
 */
fun moduleFromRawLabels(
    sources: List<String>,
    inputFile: File?,
    labelerConf: LabelerConf,
    labelerParams: ParamMap? = null,
    labelerTypedParams: ParamTypedMap? = null,
    sampleFiles: List<File>,
    encoding: String,
): List<Entry> {
    val parser = labelerConf.parser
    val extractor = parser.extractionPattern?.let { Regex(it) }
    val inputFileNames = listOfNotNull(inputFile?.name)
    val sampleFileNames = sampleFiles.map { it.name }
    val js = prepareJsForParsing(
        labelerConf,
        labelerParams,
        labelerTypedParams,
        inputFileNames,
        sampleFileNames,
        encoding,
    )
    val entries = sources.mapIndexedNotNull { index, source ->
        if (source.isBlank()) return@mapIndexedNotNull null
        val errorMessageSuffix = "in file ${inputFile?.absolutePath}, line ${index + 1}: $source"
        runCatching {
            if (parser.variableNames.isNotEmpty()) {
                requireNotNull(extractor) {
                    "extractionPattern is required but not defined $errorMessageSuffix"
                }
                val groups = source.matchGroups(extractor)
                require(groups.size >= parser.variableNames.size) {
                    "Extracted groups less than required $errorMessageSuffix"
                }
                parser.variableNames.mapIndexed { i, name ->
                    js.set(name, groups.getOrNull(i))
                }
            }

            val script = parser.scripts.getScripts(labelerConf.directory)
            js.set("input", source)
            js.execInScope(script)
            js.getJson<Entry>("entry")
        }.getOrElse {
            Log.debug(it)
            null
        }
    }

    js.close()

    return entries.postApplyLabelerConf(labelerConf)
}

/**
 * A result of [LabelerConf.Scope.Modules] parsing.
 */
@Serializable
@Immutable
data class ModuleParseResult(
    val entries: List<Entry>,
    val extras: Map<String, String> = emptyMap(),
)

/**
 * Parse entries and extras from a group of module definitions. The items in the group should have same contents expect
 * the module name. This is typically used when multiple modules are linked to a single raw label file, such as TextGrid
 * usages.
 *
 * @param definitionGroup The module definitions.
 * @param labelerConf The labeler.
 * @param labelerParams The labeler parameters.
 * @param labelerTypedParams The labeler typed parameters. Either [labelerParams] or [labelerTypedParams] should be
 *     provided.
 * @param encoding The encoding of the input file, passed to the JavaScript environment.
 */
fun moduleGroupFromRawLabels(
    definitionGroup: List<ModuleDefinition>,
    labelerConf: LabelerConf,
    labelerParams: ParamMap? = null,
    labelerTypedParams: ParamTypedMap? = null,
    encoding: String,
): List<ModuleParseResult> {
    val inputFiles = definitionGroup.first().inputFiles.orEmpty()
    val existingInputFiles = inputFiles.filter { it.isFile }
    val sampleFileNames = definitionGroup.first().sampleFiles.map { it.name }

    if (existingInputFiles.isEmpty()) {
        // No input files, fallback to default values
        return definitionGroup.map {
            ModuleParseResult(
                entries = sampleFileNames.map {
                    Entry.fromDefaultValues(it, labelerConf)
                },
                extras = labelerConf.moduleExtraFields.mapNotNull { field ->
                    field.default?.let { field.name to it }
                }.toMap(),
            )
        }
    }
    val inputFileNames = inputFiles.map { it.name }
    val js = prepareJsForParsing(
        labelerConf,
        labelerParams,
        labelerTypedParams,
        inputFileNames,
        sampleFileNames,
        encoding,
    )
    val inputs = requireNotNull(definitionGroup.first().inputFiles).map {
        runCatching { it.readTextByEncoding(encoding).lines() }.getOrNull()
    }
    js.setJson("moduleDefinitions", definitionGroup.map { it.toRawModuleDefinition() })
    js.setJson("inputs", inputs)

    val script = labelerConf.parser.scripts.getScripts(labelerConf.directory)
    js.eval(script)

    val entryLists = js.getJson<List<List<Entry>>>("modules")
    val extrasList = js.getJsonOrNull<List<Map<String, String>>>("moduleExtras")

    js.close()

    return entryLists.indices.map { index ->
        ModuleParseResult(
            entries = entryLists[index],
            extras = extrasList?.getOrNull(index) ?: emptyMap(),
        )
    }
}

private fun prepareJsForParsing(
    labelerConf: LabelerConf,
    labelerParams: ParamMap?,
    labelerTypedParams: ParamTypedMap?,
    inputFileNames: List<String>,
    sampleFileNames: List<String>,
    encoding: String,
): JavaScript {
    val js = JavaScript()
    listOf(
        Resources.classEntryJs,
        Resources.expectedErrorJs,
        Resources.envJs,
        Resources.fileJs,
    ).forEach { js.execResource(it) }
    js.set("debug", isDebug)
    val params = labelerParams ?: labelerTypedParams?.resolve(labelerConf) ?: ParamMap(emptyMap())
    js.setJson("params", params.resolve(project = null, js = js))
    js.setJson("inputFileNames", inputFileNames)
    js.setJson("sampleFileNames", sampleFileNames)
    js.set("encoding", encoding)
    js.setJson("resources", labelerConf.readResourceFiles())
    return js
}

/**
 * Create raw labels from a group of modules. This is typically used when multiple modules are linked to a single raw
 * label file, such as TextGrid usages.
 *
 * @param moduleIndexes The indexes of the modules.
 */
fun Project.modulesToRawLabels(moduleIndexes: List<Int>): String {
    val js = prepareJsForWriting()
    val relatedModules = moduleIndexes.map { modules[it] }
    js.setJson("moduleNames", relatedModules.map { it.name })
    js.setJson("modules", relatedModules.map { it.entries })
    js.setJson("moduleExtras", relatedModules.map { it.extras })

    val scripts = labelerConf.writer.scripts
    requireNotNull(scripts) { "Writer scripts are required when scope is Scope.Modules" }

    js.eval(scripts.getScripts(labelerConf.directory))
    val result = js.get<String>("output")
    js.close()
    return result
}

/**
 * Create raw labels from a single module.
 *
 * @param moduleIndex The index of the module.
 */
fun Project.singleModuleToRawLabels(moduleIndex: Int): String {
    val js = prepareJsForWriting()
    val lines = modules[moduleIndex].entries
        .map { entry ->
            val fields = labelerConf.getFieldMap(entry)
            val extras = labelerConf.getExtraMapNotNull(entry)
            val properties = labelerConf.getPropertyMap(entry, js).mapKeys { it.key.name }
            val variables: Map<String, Any> =
                fields.mapValues { (it.value as? Float)?.roundToDecimalDigit(labelerConf.decimalDigit) ?: it.value } +
                    // if a name is shared in fields and properties, its value will be overwritten by properties
                    // See source of Kotlin's `fun Map<out K, V>.plus(map: Map<out K, V>)`
                    properties.mapValues { it.value.roundToDecimalDigit(labelerConf.decimalDigit) } +
                    extras +
                    mapOf(
                        "sample" to entry.sample,
                        "name" to entry.name,
                    )
            val scripts = labelerConf.writer.scripts
            if (scripts != null) {
                for (variable in variables) {
                    js.set(variable.key, variable.value)
                }
                js.execInScope(scripts.getScripts(labelerConf.directory))
                js.get("output")
            } else {
                val format = requireNotNull(labelerConf.writer.format)
                format.replaceWithVariables(variables)
            }
        }
    js.close()
    return lines.joinToString("\n")
}

private fun Project.prepareJsForWriting(): JavaScript {
    val js = JavaScript()
    listOf(
        Resources.classEntryJs,
        Resources.expectedErrorJs,
        Resources.envJs,
        Resources.fileJs,
    ).forEach { js.execResource(it) }
    js.set("debug", isDebug)
    js.setJson("resources", labelerConf.readResourceFiles())
    js.setJson("params", labelerParams.resolve(labelerConf).resolve(project = null, js = js))
    return js
}

private fun LabelerConf.getFieldMap(entry: Entry) =
    mapOf(
        "start" to entry.start,
        "end" to entry.end,
        "needSync" to entry.needSync,
    ) + fields.mapIndexed { index, field ->
        field.name to entry.points[index]
    }.toMap()

private fun LabelerConf.getExtraMapNotNull(entry: Entry) = extraFields.mapIndexedNotNull { index, field ->
    entry.extras[index]?.let { field.name to it }
}.toMap()

private fun LabelerConf.getPropertyBaseMap(
    entry: Entry,
    js: JavaScript,
) = properties.associateWith {
    runCatching {
        js.setJson("entry", entry)
        js.execInScope(it.valueGetter.getScripts(directory))
        js.get<Double>("value").roundToDecimalDigit(decimalDigit)
    }.getOrElse {
        Log.error(it)
        0.0
    }
}

/**
 * Get a map of property names and values for a given entry.
 */
fun LabelerConf.getPropertyMap(
    entry: Entry,
    js: JavaScript,
): Map<LabelerConf.Property, Double> = getPropertyBaseMap(entry, js)

/**
 * Get a property value for a given entry.
 */
fun LabelerConf.getPropertyValue(property: LabelerConf.Property, entry: Entry, js: JavaScript): Double? =
    getPropertyBaseMap(entry, js)[property]
